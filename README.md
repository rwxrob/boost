# Beginner Boost

![WIP](https://img.shields.io/badge/status-wip-red.svg)

Every [May the 4th] I hold a free series of live-recorded *Beginner
Boost* sessions on [Twitch] and [YouTube] that run through the end of July
(or so). Below is the outline of current and planned content. This is a
living document; it changes from day to day --- even hour to hour ---
[like software].

[Twitch]: <https://twitch.tv/rwxrob>
[YouTube]: <https://youtube.com/rwxrob>
[May the 4th]: 20210503061604
[like software]: <https://github.com/rwxrob/zet/search?q=knowledge%20as%20source>

> 🌟 You may want to *Watch* this GitHub repo to be notified of updates and
changes. A *Star* would be nice as well. If you want to contribute open
an *Issue* to discuss it. Much of the content will be drawn from my
[personal Zettelkasten repo] and my [learning labs] (which you might
also want to watch for changes, but they are not always Boost related).
You can also help fund this project by clicking *Sponsor*. Thanks.

[personal Zettelkasten repo]: <https://github.com/rwxrob/zet>
[learning labs]: <https://github.com/rwxrob/lab>

## How Long Will It Take?

The Boost is about 128 days of about an hour of video for each plus 2
hours of optional AMA on Fridays. For each hour of video, most will need
to spend at least an hour (usually more) working and experimenting on
their own to learn the material. That's 256 hours *minimum* without AMA,
320 with it.

There are only four days of Boost per week, Monday through Thursday with
Fridays being two hours of AMA. That's 32 weeks, about 8 months, more
than half a year, just for the Boost content, and this is just the
*beginner* stuff.

Consider that things like the freeCodeCamp Web "certification" require
2400+ hours of time on projects and such *just for web development*.
(And I just cannot endorse any part of freeCodeCamp having witnessed it
fail for dozens in a way that gave them a false sense of having learned
it only to be shot down by reality.)

Malcolm Gladwell has suggested it takes 10,000 hours or doing something
to truly master it. Many have objectively shot down this conclusion, but
it certainly will take more than 300 hours.

In other words, this stuff takes time. There is no shortcut. Anyone
saying differently is lying to you (probably to get your money). If you
want to speed things up increase the number of hours you invest in
learning per week, by adding 10 hours on the weekend you can cut the
time for the Boost in half. It all depends on you.

## You Get *Way* More Than You Pay For

If you wondering what this training is worth, I've taken hundreds
through it at the rate of \$50/hour (about \$6400 although I had many
technical professionals tell me I could easily have charged \$100/hour
since it was one-on-one) with many getting in to colleges, elite science
boarding schools, and junior engineering jobs starting with \$100k
salaries. In every case these people put in the time --- a lot of time
--- almost entirely on their own --- to achieve these goals. You can do it
too, but you have to want it. 

This content is all yours for free now and always will be free (except
the ads). Please don't take it for granted just because it is free. Ask
someone who knows. This kind of content isn't out there anyplace else.
In fact, it's become obvious that this content is influencing other
streamers and YouTubers usually without them acknowledging it, which is
fine so long as the learning is getting done. 

Some flashy, shallow content creators have even criticized free sources
of learning like mine saying, "You get what you pay for" putting down
free learning, while pushing their own overpriced "curriculum", and
their corporate sponsors plastered all over their neon walls and tee
shirts. These unfortunate individuals just haven't learned how the
[sharing economy] works (probably because they are so busy working on
their social media marketing instead of learning and adding *real*
value). You know better. I work full-time so that I don't have to charge
you for a paywall in American dollars, plus it keeps me current so I can
pass on what's *actually* happening at work onto you.

[sharing economy]: <https://youtu.be/QX3M8Ka9vUA>

If you want to help, above all, spread the word, learn this stuff and
then do something the world *really* needs with your new skills and
knowledge. Pay it forward. 

If you insist on helping me financially, consider sponsoring me for as
little as [\$2/month on GitHub](https://github.com/sponsors/rwxrob)
where you will get a cool badge that shows you are sponsoring free and
open source content.

## Outline

* Before We Begin
   * Set Up, May the 4th Be With You
   * Motivated to Learn ¡Viva la Revolución!
   * Scientific Method, Our Greatest Learning Tool
* Get a Docker Linux Container Terminal
   * Linux Approach
   * Get on a Mac, Windows, or Linux Terminal
   * Learn About Containers and Get Docker
   * Run Linux Inside a Container
* Survive the Linux Command Line (For Now)
   * Start Using the Linux Terminal Command Line
   * Install Software from Package Manager
   * Work with File System from Command Line
   * Understand Streams, Pipes, and Redirection
   * Edit Files with Basic Vi (Then Vim)
   * Manage Users, Groups, and Permissions
* Start Scripting in POSIX Shell (Not Bash, Yet)
   * Scripts are Just Terminal Commands in a File
   * Functions, Procedures, Operations, Methods
   * State, Data Types, Variables, and Constants
   * Function and Command Communication
   * Flow, Conditions, and Logic
   * Loops, Signals, and Events
   * ANSI Escapes, Color, Gotchas, What's Next?
* Deal with Data, In a Structured Way
   * Understand the Need for Structured Data
   * Use Delimited Data (Space, Tab, Bar, Paths, CSV)
   * Use JSON, YAML, JSON-Schema Data
   * Use Bash Pattern Matching (Globbing, Globstar)
   * Use Minimal Regular Expressions (BRE, ERE, PCRE)
* Customize Interactive Bash Shell
   * Don't Blow Up, Contain and Test Customizations
   * Set Bash Options, Variables, and History Settings
   * Colorize Pager and Listed Files and Directories
   * Customize Bash Shell Prompt
   * Use Aliases and Exported Bash Functions
   * Use Tab Completion and Source Scripts Responsibly
   * Manage Bash Shell `PATH` and `CDPATH`
   * Code in Bash and Start Scripts Collection
* Customize Vi and Vim, Progressively
   * Start with Ex/Vi Configuration (`~/.exrc`)
   * Migrate from Ex/Vi to Vim 
   * Use Basic Vimscript Code (Variables, Conditions, Functions)
   * Use Basic Vimscript Concepts (Events, Maps, Types, Highlights)
   * Prefer Shell Scripts Over Plugins in Vim (`toemoji`)
   * Code a Snippets Tool in Bash for Vim (`snip`)
   * Add Custom Tab Completion to Any Bash Script
   * Use Key Plugins Judiciously
* Know How Networks Work Enough to Use and Configure Them
  * Know How the Interwebz Works
  * Know What Clients and Servers Do
  * Use Secure Shell for Remote Access
  * Use GNU Privacy Guard for Signing and More
  * Use Essential Network Commands and Utilities
  * Use Wireshark to See How Networks Work
* Manage Source Code and Knowledge with Git and GitHub
  * Use Essential Git Commands and Git Workflow
  * Compare Git Hosting Services and Use GitHub Regularly
  * Keep a Professional Portfolio on GitHub
  * Maintain a Dotfiles Repo on GitHub (dot)
  * Use GitHub for Knowledge Management (Zettelkasten, zet)
  * Become a GitHub Sponsor and Be Sponsored
* Use Terminal Multiplexers Regularly and Effectively
  * Use Screen on Any System Since 1986
  * Learn TMUX Defaults But Customize to Be Like Screen
  * Prefer Shell Over Plugins to Extend TMUX
  * Add a Pomodoro Timer to TMUX (`cmdbox-pomo`)
  * Use TMUX from Within Another TMUX Session
* Use Terminal for Just-in-Time Research
  * Use `w3m` When Available and Know Why
  * Configure and Use `lynx` and Know Why
  * Set System File Types with Mailcap
  * Integrate Web Browsing and Bookmarking Into Shell Command Line
* Create and Maintain Minimal Document-Oriented Web Sites
  * Know Markdown (CommonMark, GFM, Pandoc) and Pandoc
  * Understand the Document Object Model (DOM)
  * Know Where to Lookup Web Specifications
  * Know Enough HTML to Understand Converted Markdown
  * Know Enough CSS to Layout and Style a Page
  * Know Enough Vanilla JavaScript to Manipulate the DOM
  * Practice Progressive Design and Know Why Some Sites Suck
* Create and Manage Containers
  * Explain Containers, Cloud, Cloud-Native, Orchestration, and DevOps
  * Master Docker Fully, Optimize Dockerfiles for Different Goals
  * Create and Share a Workspace Container (Dockerfile)
  * Understand Cloud-Native, Container Orchestration Landscape
  * Use Kubernetes for Basic Container Management
  * Test and Run Kubernetes Locally with Kind
* Install and Run Linux as Your Desktop Workstation
  * Pick a Linux Distribution That Suits *You*
  * Know How to Download Linux Image and Write to USB Drive
  * Install Linux from USB Drive
  * Configure Desktop to Your Liking
* Be a Polyglot Programming Unicorn, Not a One-Trick Pony
  * Explain *Imperative* Programming
  * Explain *Procedural* Programming
  * Explain *Functional* Programming
  * Explain *Object-Oriented* Programming
  * Explain *Data-Oriented* Programming
  * Explain *Event-Driven* Programming
  * Learn Web and PWA for Web Sites and Apps
  * Learn C to Understand How Computers and Languages Work
  * Learn Perl for Rapid Prototyping and Powerful One-Liners
  * Learn Python for Math, Science, Automation, and Machine Learning
  * Learn Go for Modern Scalable Systems and Services Development
  * Learn Java for Native Mobile Apps
  * Learn Swift for Native iPhone Apps (If You Must)
  * Learn C++ for Large, Highly Performant Projects
  * Learn C# for Indy Game and Simulation Development
  * Learn SQL to Talk to Databases
  * Learn Erlang/Elixir for Fastest Possible Concurrency
  * Learn Haskell for Parsing Grammars and Pandoc
  * Learn Assembly and C for Programming Devices
  * Learn Brain-F Because It's F\*\*\*ing Cool
  * Learn COBOL to Get Rich Quick (And Don't Care What People Think)
  * Learn FORTRAN 'Cuz Maths
  * Learn Ada to Work for the Military and Blow Things Up
  * Learn Why Rust Really Isn't Worth Learning, But What the Hell
* Get Good to Gig
  * Understand the Possible Career Paths in Tech
  * Work with Others Often in a Team Setting
  * Explain the Fundamentals and Intent of the Agile Process
  * Explain Why Employment is About Trust
  * Know Why (Or Why Not) to Certify?
  * Have a Five Year Plan
  * Research Specific Target Companies 
  * Sharpen and Target Your GitHub Portfolio
  * Automate CV/Resume as a PDF from YAML
  * Manage Personal and Professional Learning
  * Make and Keep Connections
  * Keep Current
    * Newsletters to Subsciptions
    * Create Lists on Twitter 
    * Identify Worthy Podcasts
  * Land a Job You Enjoy Enough to Keep
  * Don't Let Your Job Define You
  * Share What You Know, Pay It Forward


----

# Before We Begin

## <a id=day0> Day 0: Get Set Up, May the 4th Be With You

[📺 Unedited Video](https://youtu.be/UkE2KMsVzjQ?list=PLrK9UeDMcQLre1yPasCnuKvWvyXKzmKhW)

1. [What is the purpose of Beginner Boost?](20210504161937)
1. [Beginner Boost, Day 0, Logistics](20210505025834)
   1. Ask Questions in `#ama` in [Discord] During Week
1. [Who is the Beginner Boost for?](20210505031231)
1. [Setup Essential Services][services]

[Discord]: <https://discord.gg/svqNZQ9mjY>
[services]: <https://github.com/rwxrob/zet/tree/main/20210505023938>

## <a id=day1> Day 1: Get Motivated to Learn ¡Viva la Revolución!

[📺 Unedited Video](https://youtu.be/U7BNE-AKLeI?list=PLrK9UeDMcQLre1yPasCnuKvWvyXKzmKhW)

1. [Problems with Traditional Education][prob]
1. [Help Others Learn, A Social Responsibility][social]
1. [Become an Autodidact][autodidact]
1. [Tribute to Aaron Swartz][aaron]

[prob]: <https://github.com/rwxrob/zet/tree/main/20210506155713>
[social]: <https://github.com/rwxrob/zet/tree/main/20210506160012>
[autodidact]: <https://github.com/rwxrob/zet/tree/main/20210506163935>
[aaron]: <https://github.com/rwxrob/zet/tree/main/20210506164209>

## <a id=day2> Day 2: The Scientific Method, Our Greatest Learning Tool

[📺 Unedited Video](https://youtu.be/mlecHo2p7aU?list=PLrK9UeDMcQLre1yPasCnuKvWvyXKzmKhW)

1. What did you learn about the Scientific Method?
1. The RWX Method, Refining the Scientific Method
   1. Read, Research, Reach Out, Repeat
   1. Write Who, What (If), When, Where, Why, and How
   1. Execute, Explore, Experiment, and Exercise
1. Fail Faster, Fail Better, Fail Often
1. Personal Progressive Enhancement, Layer Your Learning
1. Meritocracy in the Workplace
1. Zettelkasten (Slips in a Box) Knowledge Management System
1. Capture Thoughts as Markdown, The Syntax of Knowledge Source

# Get a Docker Linux Container Terminal

## <a id=day3> Day 3: Understand Linux Approach

[📺 Unedited Video](https://youtu.be/8myY7Ydf64g?list=PLrK9UeDMcQLre1yPasCnuKvWvyXKzmKhW)

1. What's Linux? History of UNIX and GNU/Linux
1. Do Macs Use Linux?
1. Does Windows Use Linux?
1. The UNIX Philosophy
1. How Does Linux Work?
1. When and How Should I Install Linux?

## <a id=day4> Day 4: Get on a Mac, Windows, or Linux Terminal

[📺 Unedited Video](https://youtu.be/GlpSi2LW4_Y?list=PLrK9UeDMcQLre1yPasCnuKvWvyXKzmKhW)

1. Know What a *Terminal* Is
   1. Terminal Emulators Replaced Teletype Machines
1. Know Why Humans are Generally Faster on Terminal
1. What's the Difference Between TUI and CLI?
1. What about Alacritty/Kitty or ...?
1. If Mac or Linux:
   1. Open and Configure a Terminal  
1. If Windows:
   1. Install and Configure Modern Windows Terminal  
   1. Install WSL2
   1. Can't I Just Use VSCode on Windows?
1. Consider a Good Theme, Like GruvBox or Solarized

## <a id=day5> Day 5: Learn About Containers and Get Docker

[📺 Unedited Video](https://youtu.be/YcBIUOSOAeg?list=PLrK9UeDMcQLre1yPasCnuKvWvyXKzmKhW)

1. What's a Container and Why Should You Care?
   1. The Difference Between "Container" and "Image"?
   1. Kubernetes is the New Operating System
   1. Containers are the New Programs
1. Install Docker
   1. Install Docker on Windows
      1. Why do I still need WSL2?
   1. Install Docker on a Mac
   1. Install Docker on Linux

## <a id=day6> Day 6: Run Linux Inside a Container

[📺 Unedited Video](https://youtu.be/_jJWOgZwBBs?list=PLrK9UeDMcQLre1yPasCnuKvWvyXKzmKhW)

1. Linux Distro Matters Less in Container World
   1. `docker run -it --rm ubuntu`
   1. `docker run -it --rm fedora`
   1. `docker run -it --rm archlinux`
   1. `docker run -it --rm opensuse`
   1. `docker run -it --rm nixos/nix`
   1. `docker run -it --rm kalilinux/kali-rolling`
   1. `docker run -it --rm blackarchlinux/blackarch`
1. Run Rob's Workspace Linux Container
   1. `docker run -it --rm rwxrob/workspace`
   1. Workspace Means *Not* Small (1.3GB)
1. Use Docker Basic Commands
   1. Use Docker Pull
   1. Use Docker Run
   1. Use Docker Start
   1. Use Docker Attach and Detach `Ctrl-pq`
   1. Use Docker Stop
   1. Use Docker Remove
1. Don't Worry About Dockerfile and Compose (For Now)

# Survive the Linux Command Line (For Now)

## <a id=day7> Day 7: Start Using the Linux Terminal Command Line

[📺 Unedited Video](https://youtu.be/EBtWx5m7pds?list=PLrK9UeDMcQLre1yPasCnuKvWvyXKzmKhW)

1. The Command Line, Fastest Human-Computer Interface
1. Every Command Line Entered is a Line of Shell Code
1. Use Bash, Don't Play the Shell Game (For Now)
   1. Interactive Shell is Not Same as Shell Scripting
   1. Why Bash and Not Zsh, Fish, or Whatever?
   1. Use Consistent Supported Bash Tab Completion
1. Understand the Parts of the Command Prompt
   1. Username
   1. Hostname
   1. Interesting Origin of Email Addresses
   1. Current Directory
   1. Git Branch
   1. Long Versus Short Prompts
1. Navigate Your Command History Efficiently
   1. Use Up and Down Arrow Keys (For Now)
   1. Use Initial Spaces to Stop Adding to History
   1. Use Hashtag to Make One Line Comment Notes
   1. Don't Learn More for Now (Learn `set -o vi` Later)
1. Send Special Terminal Escapes
   1. Remember, a Terminal is Just a Teletype Emulator
   1. `Ctrl-c` to Send Interrupt Signal (*Not* Copy)
   1. `Ctrl-[` to Send Exact Same as `Esc` Key
   1. `Ctrl-s`/`Ctrl-q` to Buffer and Suspend/Unsuspend
      1. "Help! My Terminal is Frozen!"
   1. `Ctrl-z` to Background Current Process (Not Quit)
   1. `Ctrl-d` to Send EOF (End of File)
   1. `Ctrl-v`, `Ctrl-x` Do Nothing (From Shell)
   1. Silencing the Terminal Bell
1. Cut and Paste from Host Operating System
   1. Depends on Terminal
   1. First Ever Mouse Had Three-Button, Middle Was Paste
   1. Windows Right Click to Paste
   1. `Ctrl-x|c|v` Don't *Usually* Work (And Shouldn't)
1. Learn Useful and Essential Beginning User Commands
   1. Use `reset` to Fix Bork Terminal
   1. Use `clear` to Clear Screen (and Alternatives)
   1. Use `watch` to Repeat Things and See Output
   1. Use `man`/`help`/`info` Commands to Get Help
   1. Use `less`/`more` for Paging Output
   1. Use `ls` Command to List Files and Directories
   1. Use `type` to See What Type of Thing It Is
   1. Use `which` to See Where Command Lives
   1. Use `pwd` Command to Show Working Directory
   1. Use `cd` Command to Change Directories
      1. Use `cd foo` to Change Into `foo` Child Directory
      1. Use `cd ..` to Change Into Parent Directory
      1. Use `cd -` to Toggle Change to Last Directory
      1. Use `cd ~` (or Just `cd`) to Change to Home Directory
      1. Don't Fall for Silly `cd` Replacements (Use `CDPATH`)
   1. Use `cal` to View Calendar
   1. Use `date` to View Dates and Times
      1. Use `date -u +%Y%m%d%H%M%S` to Get ISO Second
      1. Use `date -d 'last week'` to Exact Time Last Week
   1. Use `bc` for Floating Point Precision Math Calculations
      1. Don't Forget To Set Scale (`scale=2`)
      1. Use Semicolons for Same Line
   1. Use `top` to See Running Processes
      1. Often Replaced with `htop`

## <a id=day8> Day 8: Install Software from Package Manager

[📺 Unedited Video](https://youtu.be/6EDT-Vc4PCY?list=PLrK9UeDMcQLre1yPasCnuKvWvyXKzmKhW)

1. Create and Name a Workspace Container
   1. `docker run -it --name boost -h boost ubuntu`
      1. No Need to Mount Volumes, Will Push to GitHub Later
   1. Difference Between Detach and Exit
      1. Detach with `Ctrl-pq`
      1. Exit with `exit`
1. Understand Container States and Storage
1. Manage Software Packages from Command Line
   1. Restoring Documentation and More with `unminimize`
   1. Understand Linux Package Management
   1. Use `apt update`
   1. Use `apt upgrade`
   1. Use `apt search`
   1. Use `apt install`
   1. Use `apt remove`

## <a id=day9> Day 9: Work with File System from Command Line

[📺 Unedited Video](https://youtu.be/eZV14xpFAlA?list=PLrK9UeDMcQLre1yPasCnuKvWvyXKzmKhW)

1. [OverTheWire], Fun Hacker Practice
1. Understand the Linux File System
1. Use `mkdir` to Make a New Directory
1. Use `mktemp` to Make a New File or Directory
1. Use `rmdir` to Remove an Empty Directory
1. Use `touch` to Make a New File (or Update Timestamp)
1. Use `mv` to Move or Rename a File or Directory
1. Use `cp` to Copy a File or Directory
1. Use `rm` to Remove a File or Directory
1. Use `ln` to Link to a File or Directory
   1. What is the difference between hard and soft link?
   1. Used `ln` for Multicall Executables (BusyBox)
1. Use `file` to See What Details About File
1. Use `stat` to See Exhaustive Details About File
1. Use `cat` to Display Lines of a File, First to Last
1. Use `tac` to Display Lines of a File, Last to First
1. User `head` to Display Number of Lines at Top
1. User `tail` to Display Number of Lines at Bottom
1. Use `grep` to Find Lines of a File
1. Use `uniq` to Find Unique Lines
1. Use `sort` to Sort Lines
   1. Use `wc` to Count Lines, Words, Bytes, and Runes

[OverTheWire]: <https://overthewire.org/wargames/bandit/>

## <a id=day10> Day 10: Understand Streams, Pipes, and Redirection

[📺 Unedited Video](https://youtu.be/rhknj8h0zU8?list=PLrK9UeDMcQLre1yPasCnuKvWvyXKzmKhW)

1. Understand Standard Output and Error
   1. Use `echo` and `printf` to Print Stuff
      1. Difference Between `echo` and `printf`
      1. Never Use `print` (for Printers)
   1. Use `>` File Redirect Operator
      1. Fix `find` Command Errors with Redirection 
   1. Use `>>` File Append Operator
   1. Use `>|` Force File Overwrite Operator
1. Understand Pipes and Pipeline
   1. Use `|` Pipe Operator to Connect Out with In
   1. Power of Pipelines and Shell Integration
      1. Watch Ken Thompson Describe UNIX Pipes
      1. Pipes are at the Core of UNIX Philosophy
      1. Use Shell and Pipes from Within Applications
   1. Transform and Filter Lines
      1. Use `nl` to Number Lines
      1. Use `rev` to Reverse Line
      1. Use `tee` to Pipe *and* Redirect Lines
      1. Use `echo` for Arguments and `cat` for Lines
      1. Use `xargs` to Transform Lines Into Arguments
      1. Use `cut` to Remove Stuff from Lines of Stream
      1. Use `tr` to Translate Stuff in Lines of Stream
      1. Use `sed` to Edit Lines of Stream (Streamed `ed`) (More Later)
      1. Use `jq` to Select from JSON Input (More Later)
      1. Use `yq` to Select from YAML Input (More Later)
1. Get Standard Input Into Your Programs
   1. Input Most Useful After You Know How to Code
   1. Use `<` File Input Redirect Operator
      1. Always Use `<` Instead of `cat foo | ...`
   1. Use `<<` Here Document Operator
   1. Use `read` to Read Input
      1. Combine `printf` and `read` to Create Prompts
      1. Always Use `-r` and Understand Why
      1. Use `for` or `while` with Read for Line Loops
   1. Use `curl` to Read Input from Internet
      1. Usually Combined with `jq` or `yq`

## <a id=day11> Day 11: Edit Files with Basic Vi (Then Vim)

[📺 Unedited Video](https://youtu.be/RJ3EVB5-Emw?list=PLrK9UeDMcQLre1yPasCnuKvWvyXKzmKhW)

*Please note that I mistakenly say `Ctrl-C` many times in this video
where I actually mean `Ctrl-[`. See if you can catch all the times I get
it wrong. It will be a good way to learn from my mistake.*

1. Vi ("Visual Mode") History and Legacy
1. Why Vi/m and Not NeoVim/Emacs/Nano/VSCode?
1. Appreciate the Difference Between `vi` and `vim`
1. Restore `Esc` Key to Its Original Keyboard Home
1. Use `Ctrl-[` Instead of `Esc` Key (Never `Ctrl-x|z`)
1. Do the Vim Tutorial (`vimtutor`), But Beware
1. Other Recommended Learning Resources
   1. `:viusage`
   1. <https://openvim.com>
   1. <http://vimgenius.com> (no `s`)
   1. Vim Adventures is Strongly Discouraged
1. Start with Defaults and *Zero* Configuration
   1. Complex `.vimrc` is *Not* for Beginners
   1. Customizing `.vimrc` Requires Scripting Skills
   1. Eventually, Learn a Little Vimscript (Not Lua)
1. Avoid Vim Pane Splitting (Use TMUX Instead)

## <a id=day12> Day 12: Manage Users, Groups, and Permissions 

[📺 Unedited Video](https://youtu.be/TNdI8fNvP5k?list=PLrK9UeDMcQLre1yPasCnuKvWvyXKzmKhW)

1. How Much User Stuff Do I Need to Know?
1. Create and Manage Users and Groups
   1. Use `adduser` and `useradd` to Create User
   1. Use `su - <user>` to "Login" as User
   1. Use `deluser` and `userdel` to Delete User
   1. Use `usermod` to Modify User Settings
   1. Use `addgroup` and `groupadd` to Create Group 
   1. Use `delgroup` and `groupdel` to Delete Group 
   1. Use `groupmod` to Modify User Settings
   1. Use `passwd` to Change Passwords
   1. Know the Files Involved
      1. `/etc/passwd`
      1. `/etc/shadow`
      1. `/etc/group`
   1. Use `id` to Get the User and Group Information
   1. Use `login` to Login
      1. Does Not Register as Logged in User
   1. Use `su - <user>` to Simulate a Login as Root
   1. Understand `root` Access
      1. Use `sudo` to Grant `root` (SuperUser) Access
      1. Use `sudo su -` to Get Root Shell
      1. Use `doas -s` to Do Something As Root
      1. Know `you ALL=(ALL:ALL) NOPASSWD:ALL` in `/etc/sudoers`
         1. Acceptable for Learning and in Some Containers
         1. Usually A Really Bad Idea Everywhere Else
   1. Use `who`,`w`,`whoami`,`who am i`,`last` to See Users
1. Understand UNIX File and Directory Ownership and Permissions
   1. Use `ls -l` to See Permissions
   1. Use `stat` to See Even More About File
   1. Read, Write, and Execute Permission
      1. On Files
      1. On Directories
1. Modify Ownership and Permissions
   1. Use `chmod` to Change Permissions
   1. Use `chown` to Change Owner (and Group)
   1. Use `chgrp` to Change Group
1. Know About Setuid, Setgid, and Such, But Don't Use 

# Start Scripting in POSIX Shell

## <a id=day13> Day 13: Scripts are Just Terminal Commands in a File

[📺 Unedited Video](https://youtu.be/72OmbZiyKsc?list=PLrK9UeDMcQLre1yPasCnuKvWvyXKzmKhW)

1. You're Already Coding, Every Command *is* Code
   1. Commands are Really Just Functions with Arguments
1. POSIX Shell is a Universal Command Interpreter
   1. Shell Started as Bourne Shell, Now Ash and Dash
   1. Korn Shell Led to Bash and Zsh Interpreters
   1. Awk, Perl, Python, Ruby, Node Also Shell Scripting
1. Create First Script 
   1. Create a File Containing Some Commands
   1. Know What *Interpreted* Means
   1. Know What *Syntax* Means
   1. Use `sh` Interpreter to Run Commands in File
   1. Use `bash` Interpreter to Run Same Commands
   1. Use `perl` to Attempt Same and Note Errors
   1. Use `python3` to Attempt Same and Note Errors
   1. Use `chmod +x` to Make File Executable
   1. Add `#!/bin/sh` Shebang Line to Specify Interpreter
      1. Even If Others Work, Use to Communicate to Others
      1. Sets Vi/m Syntax So Suffix Not Needed
   1. What's Up with `/usr/bin/env`?
   1. Use `set -e` to Exit Program if *Anything* Fails
   1. Use `set -x` When Needed for Debug Tracing
1. Difference Between *Running* and *Sourcing* Scripts
   1. Use Dot (`.`) or `source` to Source a Script
   1. Most Stuff Should Be in Script (Subprocesses)
   1. Some Stuff Can't Be Done Any Other Way
      1. Change Current Working Directory
      1. Modify Current Environment
1. Put Executables in Your `PATH` to Run From Anywhere
   1. Use `which` to See Which Executable Wins
   1. Understand Difference Between `which` and `type`
   1. Never Put `./` in Your Path
1. Manage Jobs and Processes
   1. A Running Program is a *Process*
   1. A Backgrounded Program a *Job*
   1. `Ctrl-z` to Background Running Process
   1. Use `jobs` to See All Background Processes
   1. Use `fg` to Bring Background Job Forward
   1. Use `&` and `nohup` to Start and Keep Program in Background
   1. use `()` to Combine Into Single Process (Subshell)
      1. Know `$$` Still Refers to Parent
   1. Use `pgrep`, `pkill`, `kill`, `ps`, `/proc` to See Processes
   1. Use `nice` to Change Priority of Process
   1. Use `crontab` to Schedule Jobs in the Background
      1. Editing Your `crontab` is Not Really Beginner

## <a id=day14> Day 14: Functions, Procedures, Operations, Methods

[📺 Unedited Video](https://youtu.be/mgeKcAPuK7c?list=PLrK9UeDMcQLre1yPasCnuKvWvyXKzmKhW)

1. Install and Use `shellcheck` Throughout to Ensure POSIX
1. Know What *POSIX* Means [POSIX Standard]
1. Know What *Script* Means
1. Know What *Program* and *Programming* Mean
1. A Universe of Stateful, Composable Objects with Actions, Interacting
   1. Not Specifically Talking About OOP, Much Bigger
1. On Programming Humans ...
   1. Routines, Procedures, and Commands in the Real World
   1. What About *Algorithms*?
1. It All Started with Math, Know Why Linear Algebra Matters
   1. `f(x,y) = 3x + 2y + 3`
      1. `x`,`y` are *Parameters*
      1. `=`, `+` are *Operators*
      1. `3x`, `2y`, `3` are *Operands*
      1. Function Parameter Variables Receive Argument Values
      1. "This functions *returns* the value ..."
      1. Same in JS: `let z = (x,y) => 3*x + 2*y +3`
1. *True* Functions are *Not* Procedures
   1. What About *Subroutines*?
   1. What About *Methods*?
   1. What About *Operations*?
   1. What About *Commands*?
   1. Even If Language Allows, Group Code Into Either
   1. Know Advantages of One Over the Other
   1. Know What *Functional Programming* Is
   1. Know What *Side Effects* Are
1. Shell Functions Are *Not* Functions, They Are Subroutines
1. Use Action Verb When Naming
1. Use `foo() {}` to Create a Subroutine (Function)

[POSIX Standard]: <http://31.42.184.140/main/2328000/032a6956a51f4d1dd5c91aa161eee03a/IEEE%20%26%20The%20Open%20Group%20-%20IEEE%20Std%201003.1-2017%20%28aka%20POSIX%29%20%282017%29.pdf>

## <a id=day15> Day 15: State, Data Types, Variables, and Constants

[📺 Unedited Video](https://youtu.be/yHdUh6-qZw8?list=PLrK9UeDMcQLre1yPasCnuKvWvyXKzmKhW)

1. All Objects Have States: Mutable, Immutable, Persistent, Dynamic, Static
1. Variables Save Data as State
1. Types Declare How to View State Data
   1. Same Data, Different Type
   1. Binary (Base 2, Ones and Zeros, Digital)
   1. Number 
   1. Symbol or Letter
   1. String
   1. Bit Field 
   1. POSIX Shell Only Has Strings and Integers
   1. Use Strings for Everything
1. Function Parameter Variables Receive Argument Values
   1. Like Putting Something Into Box or on List
1. Use `=` to Declare and Assign Variable
   1. No Spaces Around Operator (`=`)
1. Use `$foo` to Use Variable After Assigned
1. *Always* Wrap with Double Quotes (`"$foo"`)
1. Use `"${foo}bar"` to Disambiguate
1. Don't Forget to Check with `shellcheck`
1. Use `bc` When Numbers and Math are Actually Needed
1. Understand *Scope* and Considerations
   1. Know What *Scope* Means
   1. Know What a *Block* Is
   1. Know What *Global* Means
   1. Know What *Local* Means
1. All Variables are Global in POSIX Shell

## <a id=day16> Day 16: Function and Command Communication

[📺 Unedited Video](https://youtu.be/Gv-39gfhKR8?list=PLrK9UeDMcQLre1yPasCnuKvWvyXKzmKhW)

1. *Calling* to Communicate
   1. Know What to *Call* a Function or Subroutine Means
   1. Arguments Contain Incoming Communication
   1. Return Values Produce Outbound Communication
   1. Calls Must Come After Declarations
1. Arguments Passed as Special Parameter Variables: `$1`, ...
   1. No Parameters Between Parens `()`
   1. Unlike Most Other Languages
1. Use `$0` to Get Name/Path of Executable Script
1. Use `$#` to Get the Total Number of Arguments Passed
1. Use `"$@"` for `"first" "second" "third"`
1. Use `"$*"` for `"first second third"`
1. Reminder About Necessity of Quoting (`"foo"`) Everything
1. Shell Functions Only Return Integers
   1. Use `return [RVALUE]` to Set Return Value
   1. Omitting `return` is Fine
   1. Return Values are *Not* Output
   1. Use `echo`/`printf` and `$(foo)` to "Return" Strings
1. Use `$?` for Last Return Value
1. Use `exit [RVALUE]` to Return Value for Program Itself

## <a id=day17> Day 17: Flow, Conditions, and Logic

[📺 Unedited Video](https://youtu.be/Nvsae1lVPwY?list=PLrK9UeDMcQLre1yPasCnuKvWvyXKzmKhW)

1. Conditions Alter Flow
1. Use `test` to Check Condition (Read `test` Man Page)
   1. Remember, `test` Not Needed for Single Command
1. Use `&&` and `||` to Create *Compound Conditions*
1. Use Range Notation (like `20 < i < 100`)
1. Know and Use *Short-Circuit Logic*
   1. Use `test` to Keep it Clear to Read
   1. Use `&&` to Join (Not `||`)
1. Use `set -e` to Assert Every Line or Exit
   1. Use `|| true` to Make Assertion Optional
1. Avoid Problematic `[]` to Check Conditions
1. Use `if` to Group Commands If True
1. Avoid `else` Whenever Possible, Return Early Instead
1. Use `case` to Branch Multiple Conditions

## <a id=day18> Day 18: Loops, Signals, and Events

[📺 Unedited Video](https://youtu.be/_NJi33h_Obk?list=PLrK9UeDMcQLre1yPasCnuKvWvyXKzmKhW)

1. Power of Loops on the Command Line
   1. Use `watch` for Simple Repetition
   1. Iterating Over Ranges and Items
   1. Creating Small Monitors and Services
1. Loops Repeat Commands Until Condition Met
   1. Use `while` to Repeat While Condition True
   1. Use `while true` for Infinite Loops
   1. Use `sleep` to Lessen Impact to System
   1. Use `until` to Repeat Until Condition True
   1. Avoid Loops That Require Math in POSIX Shell
      1. But If Needed, Remember, Integer Only
   1. Understand "Init", "Check", "Change"
      1. Arithmetic `for` Loops are Not POSIX
      1. Can Be Done with `while` in POSIX
   1. Use `for` to Repeat for Sequence or Number of Items
      1. Use `seq` Instead of Bash `{1..10}` Notation
   1. Use `break` to Break Out of Any Loop
   1. Use `continue` to Start Next Iteration Early
1. Unexpected Benefits of Loops for Editing
1. Know What *Inter-Process Communication (IPC)* is and Methods
   1. Signals are Just One IPC Method
1. Signals Communicate Between Programs
   1. Use `kill`, `pkill` to Send a Signal
      1. Use `Ctrl-C` from Within Process to Send Interrupt
      1. Use `kill` to Send Terminate
      1. Use `kill -1` to Send Hangup (Reread Config)
      1. Use `kill -9` to Send Kill When Not Responding
      1. No Need to Learn Others (For Now)
   1. Use `trap` to Handle a Signal
1. Use Loops, `nohup`, and `&` to Create *Daemons*
   1. Judicious Use of `&` Can Improve Concurrent Tasks
   1. Better to Use `screen` or `tmux` (More Later)
1. Use `exec` to Exit a Program When Possible
   1. Hands Off All Resources, Including Signal Handling

## <a id=day19> Day 19: ANSI Escapes, Color, Gotchas, What's Next?

[📺 Unedited Video](https://youtu.be/VGbFGlUoa7I?list=PLrK9UeDMcQLre1yPasCnuKvWvyXKzmKhW)

1. Happy Pride Month!
1. Don't Fear Color, All Modern Terminals Have Support
1. Know When to Use Color and When to Not
   1. Use `test -t 1` to Detect Terminal Output
   1. Use `reset` When You Break Your Interactive Terminal
1. Know What *ANSI Escapes* are, Which to Use, and How to Lookup
1. Use `printf` Because Escapes `\e` Properly
   1. Avoid `echo -e` Which is Not POSIX
1. Prefer 16 Terminal Theme Colors for Compatibility
   1. Use `\e[30m`-`\e[37m` for Terminal Theme Colors
   1. Use `\e[1;30m`-`\e[1;38m` for "Bright/Bold" Variations
   1. Add 10 for Background Colors
   1. Use `\e[H\e[2J` to Clear the Screen
   1. Use `\e[0m` to Reset Color
   1. Avoid Dependencies from Sourcing Color Libraries
      1. Write a [`termcolors`] Script, Run from Vim
1. Use Specific Colors When Needed
   1. Understand These are *Never* Relative to Terminal Theme
   1. Set `TERM` to `xterm-256colors` (or Whatever)
   1. Use `\e[38;5;Nm` for "Hundreds" of Colors ( 0 <= N <= 255)
   1. Use `\e[38;2;R;G;Bm` for "Millions" of Colors ( 0 <= R,G,B <= 255)

1. Conclusion of POSIX Shell Scripting
   1. What's Next for Shell Coding
   1. Learn Bash `RANDOM` for Fun
   1. Learn POSIX Parameter Expansion
   1. You Just Don't Need `awk`, Ever
   1. Sometimes You Need `sed` to Remain POSIX Compliant
   1. Don't Use `expr`, It's Deprecated
   1. POSIX -> Bash / Perl -> Python / CmdBox Go (Not Shell, But Still)
   1. Learn Bash *After* Coding a Lot of POSIX First
      1. Bash is Fine, When You Have It
      1. Much Better Parameter Expansion
      1. Safe Double Bracket Conditions
      1. Regular Expression Support (Never Use `sed`)
      1. Use `select` for Instant Interactive Menus
      1. Read Google Bash Style Guidelines
      1. It is Very Difficult to Keep Bashisms Out of Your Head
   1. Node and Deno If You Must Have JavaScript
   1. Ruby is Great as Well (If You Need It)
1. Some Fun Challenges to Get You Started
   1. <https://rwx.gg/lang/cha>
1. Other Resources

[`termcolors`]: <https://raw.githubusercontent.com/rwxrob/dot/main/scripts/termcolors>

# Deal with Data, In a Structured Way

*Remember purpose of Boost is not to cover in depth, but to give a sense
of what you need to know and why. Mastering these topics (SQL, for
example) could take several months alone, writing your own language
grammar in PEGN, a year or more*

## <a id=day20> Day 20: Understand the Need for Structured Data

[📺 Unedited Video](https://youtu.be/rckWMl7MG2Y?list=PLrK9UeDMcQLre1yPasCnuKvWvyXKzmKhW)

1. What is Data?
1. Evolution of Data Utilization
1. Delimited Data (WS, Tab, Bar, Paths, CSV)
1. Universal JSON, YAML, and JSON-Schema Data
1. Could TOML Be the Future?
1. Pattern Matching (Globbing, Globstar)
1. Matching and Parsing with Regular Expressions

Other important structured data formats to know:

* gRPC and ProtoBuf
* Hashicorp Configuration Language (HCL)
* ABNF, EBNF, PEG, and PEGN Specification Languages
* Structured Query Language (SQL)
* Markdown
* INI and TOML
* HTML
* XML

## <a id=day21> Day 21: Delimited Data (Space, Tab, Bar, Paths, CSV)

[📺 Unedited Video](https://youtu.be/XueMgR7Im40?list=PLrK9UeDMcQLre1yPasCnuKvWvyXKzmKhW)

1. Describe Differences Between Delimited Data Formats
1. Name Common Applications and Uses of Delimited Data
1. Know the Different Forms of *White Space* 
1. Know the Difference Between `PATH` and File Path 
1. Use Parameter Expansion to Get Prefix and Suffix
1. Use `cut` To Get At Stuff In The Middle (But Careful, Not Greedy)
1. Use `awk` If You Really Want (But You Don't Need It)
1. Use `tr` or `sed` to Change the Delimiter or "Squeeze" (Spaces, etc.)
1. Understand Input Field Separator (IFS) (Maybe use `()`)
1. Understand the Problems with CSV (Not the Source Manager)

## <a id=day22> Day 22: Universal JSON, YAML, JSON-Schema Data

[📺 Unedited Video](https://youtu.be/3addpYgC3CU?list=PLrK9UeDMcQLre1yPasCnuKvWvyXKzmKhW)

1. What is JSON and Why Does it Matter?
   1. JSON is for Parsing, Not People
   1. "Should I Use JSON5?" HELL NO!
1. What is YAML and Why Does it Matter?
   1. YAML is for People and Programming
1. Know the Definition of *Schema*
1. Know the Definition of *Domain Model*
1. Use `jq`/`yq` to Parse and Output JSON/YAML Data
   1. Install `jq` with `sudo apt install jq`
   1. Install `yq` However
   1. Always Surround Query in Single Quotes

## <a id=day23> Day 23: Pattern Matching (Globbing, Globstar)

[📺 Unedited Video](https://youtu.be/PUAFYaUSzIE?list=PLrK9UeDMcQLre1yPasCnuKvWvyXKzmKhW)

1. Use `shopt` to Activate Pattern Matching in Bash Shell
1. Use `*` to Match Zero or More of Anything
1. Use `**/` to Descend Into All Directories as Well
1. Use `?` to Match Exactly One of Anything
1. Use `{foo,bar}` to Match `foo` or `bar`
1. Use `[a-c]` to Match `a`, `b`, or `c` (Like `{a,b,c}`)
1. Use `[^a-c]` Match *Anything But* `a`,`b`, or `c`
1. Use `[^.]*` to Match All Non-Hidden Files
1. Skip POSIX Character Classes (For Now)
1. Know the Limitations of Globbing
   1. Glob on the Command Line, But Avoid in Scripts
   1. Extended Globbing (`**`, etc.) is Not POSIX
   1. Can Expand Past Maximum Command Line Length
      1. Consider `find` Instead When Needed
   1. Know When a Regex Is Better
1. Learning Resources
   1. Use Globbing for Static Site Generator ([20210327130106])

[20210327130106]: <https://youtu.be/Efk2M77naFU>

## <a id=day24> Day 24: Match and Parse with Regular Expressions

[📺 Unedited Video](https://youtu.be/vCTg-EqKvEk?list=PLrK9UeDMcQLre1yPasCnuKvWvyXKzmKhW)

1. Know What a *Regular Expression* (Regex) Is
1. Know Regex is for Matching *And* Parsing
1. Use `Deny` Then `Allow` Approach with Regex Validation
   1. Basis of Perl Taint (`-T`)
1. *Never* Use the Deprecated `expr` for Anything
1. Use `[[ =~ ]]` / `[[ != ]]` in Bash When Needed and Available
1. Use `sed` or `grep` if You Must
   1. Basic Regular Expressions (BRE) Only
   1. Just Don't Clutter Brain with BRE
1. Use Perl Regex Whenever Possible
   1. Perl Set the Standard for Modern Regex (PCRE)
   1. Use `\s` to Match White Non-Whitespace Class
   1. Use `\S` to Match White Whitespace Class
   1. Often `\s` and `\S` is All That's Needed
   1. Use `\w` for Word Character Class
      1. Remember `_` is Considered AlphaNumeric
   1. Use `\b` to Match Word Boundary
   1. Use `\p{}` to Match Unicode Properties
   1. Use `[]` to Match Non-Standard Classes
1. Learn Extended Regular Expressions Because UNIX Uses It
1. POSIX Character Classes Less Relevant in Unicode World
   1. The `[:lower:]` is Not Same as `Ll`
1. Use Alternatives When Possible and Necessary
   1. Parameter Expansion
   1. Substring Matches
1. Know Advantages of Regex Over Other Parsing Methods
   1. Powerful
   1. Succinct
   1. Universal
1. Know Limitations of Regex Versus Other Parsing Methods
   1. Some Grammars Cannot Be Represented
   1. Often Unnecessary Overhead
      1. Cognitive
      1. Technical
1. Learning Resources
   1. <https://alf.nu/RegexGolf>
   1. <https://regex101.com/>
   1. <https://regexr.com>
   1. <https://xkcd.com/1313>

# Customize Bash Interactive Shell

## <a id=day25> Day 25: Don't Blow Up, Contain Your Customizations

[📺 Unedited Video](https://youtu.be/rTLGsG7cs6U?list=PLrK9UeDMcQLre1yPasCnuKvWvyXKzmKhW)

1. Review Why Containers are Best for Learning
   1. Shell Configurations are Riskier Than Most 
   1. Explore and Experiment Without Fear
   1. Don't Worry Amount Mounting Volumes (For Now)
   1. Containers are Persistent (Until Deleted)
   1. It's Perfectly Fine to Persist a Container While Learning
   1. Eventually Push to GitHub as Backup
1. Start with a Fresh Ubuntu Container
   1. Review Day [6](#day6),[7](#day7),[8](#day8)
1. Create a New User (See [Day 12](#day12))
1. Understand `/etc/skel` and Why It Matters
1. Understand What *Hidden* Means
1. Understand What *FreeDesktop* is About
   1. <https://freedesktop.org>
   1. Learn the [XDG Specification]
   1. Use `~/.local/bin` Instead of `~/bin`
   1. Use `~/.config/foo` Instead of `~/.foo`

[XDG Specification]: <https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html>

## <a id=day26> Day 26: Set Bash Options, Variables, and History Settings

[📺 Unedited Video](https://youtu.be/3kEBhmMnk6M?list=PLrK9UeDMcQLre1yPasCnuKvWvyXKzmKhW)

1. Connect to Your Saved Boost Container
   1. `docker start -a boost`
1. Use `su - me` to Become Me (Or Whatever)
   1. Know Difference Between `su` and `su -`
1. Install `vim`, `less`, `sudo`
1. Add `me` to `/etc/sudoers` with `visudo`
   1. `me ALL=(ALL:ALL) NOPASSWD:ALL` (For Now)
1. *Never* Mess with Dotfiles from Installers
1. Don't Worry About `~/.bash_history` and `~/.viminfo`
1. Delete `~/.profile` (Not Used)
1. Delete `~/.bash_logout` (You Know Better)
1. Delete `~/.bashrc` (New One Coming)
1. Use `case` and `$-` to Detect Interactive Shell
1. Export `TERM`, `EDITOR`, `VISUAL` Variables
1. Export `TERM`, `EDITOR`, `VISUAL` Variables
1. Add `lessfile` / `lesspipe` Code
1. Add `HISTCONTROL`, `HISTSIZE`, `HISTFILESIZE`
1. Set `histappend` Shell Option
1. Set Vi History Editing Mode `set -o vi`
   1. "Emacs" Mode is the Default (And Really Bad)
1. Add Your First Alias `alias c='printf "\e[H\e[2J"'`

## <a id=day27> Day 27: Colorize Pager, Files, Directories (ls)

[📺 Unedited Video](https://youtu.be/a8zeMPEC0HA?list=PLrK9UeDMcQLre1yPasCnuKvWvyXKzmKhW)

1. Reconnect to Your Boost Container
1. Add Terminal Escapes to Special Variables for `LESS`
   1. Remember, Use `reset` if Your Terminal Messes Up
   1. Do *Not* Use `MANPAGER` Color Method (Too New)
1. Add Directory Colors with `dircolor`
   1. Use `command -v dircolors` to Check If Have It
   1. Use `eval $(dircolors -b)` to set `LS_COLORS`
   1. Set `alias ls='ls -h --color=auto'`
   1. Add Custom `~/.config/ls/dircolors` 
      1. Use `mkdir -p ~/.config/ls` to Make Directory
      1. Get One From Net with `curl` (Install `curl` if Needed)
   1. Use `test -r ~/.config/ls/dircolors` to Check for File
   1. Use `eval $(dircolors -b ~/.config/ls/dircolors)`
   1. Customise to Personal Style

## <a id=day28> Beginner Boost, Day 28: Customize Bash Shell Prompt

[📺 Unedited Video](https://youtu.be/iR3zh3lau5g?list=PLrK9UeDMcQLre1yPasCnuKvWvyXKzmKhW)

1. Reconnect to Your Boost Container
1. Just Say No to "Oh-My-Zsh" and Such
1. Understand the Science Behind Prompts
   1. Older: Smaller Prompts Focus on What's Important
   1. Newer: I Have Too Much to Communicate
   1. Pay Attention, Don't Be Me (Story: Shutdown Company Mail Server)
1. Review What is Actually Useful to Have in Prompt
1. Build Up Gradually from Command Line First
1. Change `PS1` to Alter Prompt
   1. Know Difference Between Single and Double Quotes
1. Read `man bash` (Use `/prompting` to Find)
1. Use `PROMPT_COMMAND` to Run Function for Each Command
1. Alter `PS1` from `PROMPT_COMMAND` Code for Creativity
1. Use ANSI Escapes for Color (See Day 19)
   1. Use `\[`/`\]` to Keep Spacing Correct

## <a id=day29> Beginner Boost, Day 29: Use Aliases and Exported Bash Functions

[📺 Unedited Video](https://youtu.be/whlraJbk92E?list=PLrK9UeDMcQLre1yPasCnuKvWvyXKzmKhW)

1. Know What an *Alias* Is
   1. Use `alias` to Create Aliases
   1. Affect Current Interactive Shell
   1. Aliases Do *Not* Propagate to Subprocs
   1. Aliases Cannot Be Exported
1. Know What an *Export Function* Is
   1. Use `foo(){} && export -f foo` to Export Functions
   1. Affect Current Interactive Shell
   1. Functions Do *Not* Propagate to Subprocs Unless Exported
   1. Exported Functions Affect Bash Subshells (Not Subprocs)
1. Use Initial Backslash (\) to Disable Aliases/Functions
1. Use `shopt expand_aliases` to Ensure Active
1. Know When to Use a Alias vs Function
1. Know About "ShellShock" and How It Happened
1. Remember, Scripts are Almost Always Better
   1. Except When Changing Current Interactive Shell

## <a id=day30> Beginner Boost, Day 30: Tab Completion and Sourcing

[📺 Unedited Video](https://youtu.be/il6nnouiF34?list=PLrK9UeDMcQLre1yPasCnuKvWvyXKzmKhW)

1. Know What *Tab Completion* Is
1. Use `<TAB>` to Page Through All Possible Commands 
   1. Major Examples Include `git`, `pandoc`, `docker`, `kubectl`
1. Use `complete` to View All Completion Rules
1. Use `complete -C foo foo` to Build Completion Into Script
1. Copy Completion Rule to Make Shortcut (`docker` -> `d`)
1. Understand *Completion Mode* vs *Regular Mode* Execution
   1. Check for `COMP_LINE` Environment Variable
   1. Print Completion Possibilities One Per Line
   1. Works for Any Language
1. Use Completion Helper Libraries When Possible
   1. Shun Go `Cobra` as a Disease (14k Lines for `kubectl`)
   1. Consider `compgen` to Create Complete Shell
   1. Consider Go CmdTab (When Finished)

## <a id=day31> Beginner Boost, Day 31: Manage Bash Shell Executable `PATH` and `CDPATH`

[📺 Unedited Video](https://youtu.be/pOr7Wt72INo?list=PLrK9UeDMcQLre1yPasCnuKvWvyXKzmKhW)

1. Make *Sure* You are Attached to Container
1. Create `~/.local/bin/` Directory for Executables
1. Add `export PATH=$HOME/.local/bin:$PATH` to Test
1. Try `unset PATH` ***FROM CONTAINER*** as Experiment
1. Remember `/usr/bin/vi ~/.bashrc` to Fix Things
1. Use `printf "${PATH//:/\\n}"` for Pretty `path`
1. Add `pathappend` and `pathprepend` for PATH Management
1. Never Put `./` in Your `PATH`
1. Always Put `./` in Your `CDPATH` (If You Have One)

## <a id=day32> Beginner Boost, Day 32: Code in Bash and Keep Scripts Collection

[📺 Unedited Video](https://youtu.be/mHdmHvoTLto?list=PLrK9UeDMcQLre1yPasCnuKvWvyXKzmKhW)

1. Learn POSIX First *Then* Bash
1. Example of Utility Script `lynxa`
1. Use `shellcheck` and Just Don't Worry About It
1. The Quick Hit and Attraction of Script Creation
1. Use Progressive Enhancement, Least Possible Tech First
1. Always Read Every Line of Any Script You Put In Your Scripts Directory
1. Don't Just Add Things You Don't Understand
1. Consider Comparing to Checksums (Man In the Middle)
1. Create a `~/.local/bin` for Now
1. Consider Creating a `SCRIPTS` Environment Variable
  1. Add `alias scripts='cd $SCRIPTS'`
1. Put Your Script in Directory
1. Create Shortcut Commands and Functions to Use
   1. `newx`
1. Now That You Know POSIX and Some Bash, Learn the Rest
   1. Read and Explore `man bash`
   1. Read and Explore [Google Shell Scripting Guidelines]
     1. Personal Opinions About
        1. Disagree with Over Commenting
        1. Disagree with Unnecessary Curlies `${SOME}`
        1. Agree Strongly With If over 500 lines use something else.
1. Start with Simple One-Liners
   1. Experiment Using from Vi/m

[Google Shell Scripting Guidelines]: <https://google.github.io/styleguide/shellguide.html>

## <a id=day33> Beginner Boost, Day 33: Start with Ex/Vi Configuration

[📺 Unedited Video](https://youtu.be/ZXUb1T-KTsM?list=PLrK9UeDMcQLre1yPasCnuKvWvyXKzmKhW)

1. Install `vim` Into Boost Container
1. Install `nvi` Into Boost Container (Not `nvim`)
1. Know the History of `ed`, `ex`, `vi`, `vim`, `nvi`, and `nvim`
1. Use `:viusage` to Show How to Use `vi`
1. Use `set all` and `man nvi` for List of Configurable Settings
1. Know Which [Settings][visettings] Work with `vi`, `nvi`, and `vim`
1. Put `vi`/`nvi` Configuration Settings in `~/.exrc` (For Now)
1. Use `set number` to Enable Line Numbers
1. Use `set mode` to Show `INSERT` When Inserting
1. Use `set ruler` to Show Position in File
1. Use `set tabstop=2` for 2-Space Tab
1. Use `set autowrite` to Save When Editing Multiple on Switch

[visettings]: <http://users.softlab.ntua.gr/~sivann/books/Unix%20Hints%20+%20Hacks/here/19270116.htm>

## <a id=day34> Beginner Boost, Day 34: Migrate Vi/Ex to Vim

[📺 Unedited Video](https://youtu.be/AxQ4EMWaH6o?list=PLrK9UeDMcQLre1yPasCnuKvWvyXKzmKhW)

1. Move or Copy `~/.exrc` to `~/.vimrc`
1. Use `set nocompatible` to Start with Vi Compatibility
   1. Vim in Compatibility Mode is *Not* `vi` Compatible
   1. Always Use `nvi`, or `vi` or Original to Check Compatibility
1. Add `set expandtab` to Replace Tabs with Space
1. Add `set softtabstop=2` to Sync Tab Settings
1. Add `set smarttab` to Sync Tab Settings
1. Add `set shiftwidth=2` to Set Angle Bracket Shifting
1. Add `set smartindent` to Work with `autoindent`
1. Use `:set paste` When Pasting Text Copied with Mouse

## <a id=day35> Beginner Boost, Day 35: Vimscript (echo, messages, let, if, function, commands)

[📺 Unedited Video](https://youtu.be/px74GhBAG9I?list=PLrK9UeDMcQLre1yPasCnuKvWvyXKzmKhW)

1. Know What *Vimscript* is and Why to Use It
   1. Harder to Grok Because `.vimrc` Compatible
   1. Modify an Existing Plugin
   1. Add Minor Modifications to Your `.vimrc`
1. Know Where to Learn More Vimscript
   1. Use Self-Documentation: `:viusage`, `:help`, `:set all`
   1. <https://learnvimscriptthehardway.stevelosh.com/>
   1. Mastering Vim, O'Reilly
1. Use `echo`/`echom` to Send Messages
1. Use `:messages` to Former Error Messages
1. Use `set` for Options
1. Use `let` for Variables
1. Use `if`/`elseif`/`endif` for Conditions  
1. Use `fu[nction]`/`endf[unction]` for Functions
   1. Use `:echom YourFun()` to Test and See Return Values
   1. Must Start with Uppercase
1. Use `command` to Define Ex Commands
   1. Example: `com! Greet call Greet()`
   1. Must Start with Uppercase

## <a id=day36> Beginner Boost, Day 36: Vimscript (highlight, filetype, autocmd, map)

1. Have `export TERM=xterm-256color` in Your `~/.bashrc`
1. Use `:highlight` to See and Set Color Groups
1. Use `synstack` in Function and Command to See Groups of Existing 
1. Use `au[tocmd]` to Map Events to Functions and Highlighting
1. Use `map`, `nmap` to Map Keystrokes
1. Use `hi` to Set Default, Use `au FileType * hi` to Override
1. Know How Much to Tweak and When to Stop
   1. Keep `.vimrc` Portable and in Single File
1. Don't Use Visual, Use Shell Script Filters Instead

## <a id=day37> Beginner Boost, Day 37: Prefer Shell Scripts Over Plugins in Vim (toemoji)

[📺 Unedited Video](https://youtu.be/2o3URIxG3Zs?list=PLrK9UeDMcQLre1yPasCnuKvWvyXKzmKhW)

1. What is the UNIX Philosophy and what does it have to do with Vim?
1. Examples of Shell Integration
1. Code a `toemoji` Shell Script Vim Filter

## <a id=day38> Beginner Boost, Day 38: Code a Snippets Tool in Bash for Vim (snip)

[📺 Unedited Video](https://youtu.be/P0XHOSHM2SU?list=PLrK9UeDMcQLre1yPasCnuKvWvyXKzmKhW)

1. Create a `snippets` Directory
1. Set `SNIPPETS` to Point to `snippets` Directory in `~/.bashrc`
1. Create `snippets` Alias to `cd $SNIPPETS`
1. Create a New Bash Script Called `snip`
   1. Check for SNIPPETS Environment Variable or Exit
   1. Create a `snip` Function That Take One Parameter: `name`
   1. Join Argument `name` with `$SNIPPETS` for File
   1. Load the File Into Variable `buf`
   1. Print `buf` to Standard Output
1. Add Template Parameters to `snip`
   1. Update `snip` to Use All Extra Arguments as Values
   1. Replace `{1}`,`{2}`, ... with Values for Printing
   1. Recursively Call `snip` Rather than Rewrite
1. Add Template Parameters from Lines of Input
   1. Update `snip` to Assume Arguments are as Input lines
   1. Do the Same at Previous

## <a id=day39> Beginner Boost, Day 39: Add Custom Tab Completion to Any Bash Script

[📺 Unedited Video](https://youtu.be/Ih903YwCKTc?list=PLrK9UeDMcQLre1yPasCnuKvWvyXKzmKhW)

[Snippet from
Video](https://raw.githubusercontent.com/rwxrob/dot/main/snippets/sh/compc)

1. Bash Really is the Best First Language
1. Create a New Script in Your Scripts Directory
1. Find *Programmable Completion* in the Bash `man` Page
1. Read About `complete -C foo foo` and What It Does
1. Check for the `COMP_LINE` Environment Variable
1. Create an Array of Commands That Will Be Functions
1. Loop and Echo Commands Starting With *Second* Argument 
1. Force Lowercase for Case Insensitive (If You Want)
1. Exit if in Completion Mode, Rest is Regular Mode
1. Add Commands with Underscore Prefix
1. Loop Commands and Delegate if Match
1. Add to Snippets Collection
1. Ideas for Ways to Improve

## <a id=day40> Beginner Boost, Day 40: Use Key Vim Plugins Judiciously

[📺 Unedited Video](https://youtu.be/pxTeezSVstQ?list=PLrK9UeDMcQLre1yPasCnuKvWvyXKzmKhW)

1. What Does Judiciously Mean?
1. Priority on Portability
1. Why is Plug So Awesome?
1. What About the Builtin Plugin Manager?
1. What About Language Server Protocol (LSP)?
1. I Don't Like Code Completion
1. Find the Ones You Like and Share
1. I Don't Like Graphic Plugins
1. What About NerdTree?
1. The Toolbox Analogy, Pretend Your Space is Limited

# Know How Networks Work Enough to Use and Configure Them

## <a id=day41> Beginner Boost, Day 41: Know How the Interwebz Works

[📺 Unedited Video](https://youtu.be/A-coiMZYF1g?list=PLrK9UeDMcQLre1yPasCnuKvWvyXKzmKhW)

1.  Welcome to Day One of Networking Week
2.  What is the Internet and where did it come from?
    1.  Go Watch “Nerds 2.0.1: A Brief History of the Internet”
3.  Ordering a Package (Packet) Analogy
4.  Why learn networking? What jobs are in networking?
    1.  Network and Infrastructure Engineering
    2.  Cloud and Cloud-Native
    3.  Networking Security / Pentesting / Hacking
    4.  Software Engineering and Architecture
    5.  Basically, Every Technical Career Involving a Network
5.  Ways to learn networking?
    1.  Build Your Own Virtual or Real Lab
    2.  Use a Lab at School
    3.  Read TCP/IP Illustrated (or Something Similar)

## <a id=day42> Beginner Boost, Day 42: Know What Clients and Servers Do

[📺 Unedited Video](https://youtu.be/rTP1ME43vCM?list=PLrK9UeDMcQLre1yPasCnuKvWvyXKzmKhW)

1.  Know the Seven Layers of Networking
    1.  Physical Layer: Cat 5/6, Fiber
    2.  Data-Link Layer: Ethernet
    3.  Network Layer: IP
    4.  Transport: TCP, UDP
    5.  Session: gRPC
    6.  Presentation Layer: Translation, Compression
    7.  Application Layer: HTTP, SMTP, TLS, RTMP
2.  Know what a Network Topology Is
3.  Watch Web Requests with Web Browser
4.  Use curl to Deal Directly with Client Requests
5.  Create a Client/Server “Backdoor” App with Netcat
    1.  Start a New Docker Container with Port 6868 Exposed
    2.  Install netcat
    3.  Use netcat -l -p 6868 to Start a Server
    4.  Open a New Terminal and Connect to 6868 with nc localhost 6868
        1.  “There’s No Place Like 127.0.0.1”

